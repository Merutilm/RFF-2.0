#version 450

layout (set = 0, binding = 0) uniform sampler2D srcImage;
layout (set = 0, binding = 1) writeonly buffer BGRSSBO {
    uint data[];
} bgr_ssbo_attr;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

ivec4 get_color255(int index, ivec2 extent) {
    return ivec4(texelFetch(srcImage, ivec2(index % extent.x, index / extent.x), 0) * 255);
}

void main() {



    ivec2 extent = textureSize(srcImage, 0);
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    int index = gid.y * extent.x + gid.x;



    //  x0       x1       x2       x3
    //  R G B A  R G B A  R G B A  R G B A
    //  B G R B  G R B G  R B G R  B G R B
    //  x0    x1     x2     x3     x4

    //  memory stores reverse order
    //  0        1        2        3
    //  B R G B  G B R G  R G B R  B R G B ...
    //  1 0 0 0  2 2 1 1  3 3 3 2  5 4 4 4

    //    int index3 = index * 3;
    //    int arrIndex = index3 / 4;
    //    int arrOffset = index3 % 4;
    //    int shift = arrOffset * 8;

    //    vec4 col = texelFetch(srcImage, gid, 0);
    //    atomicAdd(bgr_ssbo_attr.data[arrIndex], uint(col.b * 255) << shift);
    //
    //    shift = (shift + 8) % 32;
    //    if (shift == 0) ++arrIndex;
    //
    //    atomicAdd(bgr_ssbo_attr.data[arrIndex], uint(col.g * 255) << shift);
    //
    //    shift = (shift + 8) % 32;
    //    if (shift == 0) ++arrIndex;
    //
    //    atomicAdd(bgr_ssbo_attr.data[arrIndex], uint(col.r * 255) << shift);

    int size = extent.x * extent.y;
    int arr_len = size * 3 / 4;


    int i1 = index * 4 / 3;
    int i2 = i1 + 1;

    if (arr_len <= index) {
        return;
    }

    ivec4 c1 = get_color255(i1, extent);
    ivec4 c2 = i1 == arr_len - 1 ? ivec4(0, 0, 0, 255) : get_color255(i2, extent);

    switch (index % 3) {
        case 0:
            {
                bgr_ssbo_attr.data[index] = c2.b << 24 | c1.r << 16 | c1.g << 8 | c1.b;
                return;
            }
        case 1:
            {
                bgr_ssbo_attr.data[index] = c2.g << 24 | c2.b << 16 | c1.r << 8 | c1.g;
                return;
            }
        case 2:
            {
                bgr_ssbo_attr.data[index] = c2.r << 24 | c2.g << 16 | c2.b << 8 | c1.r;
                return;
            }
    }


}